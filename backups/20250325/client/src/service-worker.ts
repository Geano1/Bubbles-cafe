import { clientsClaim } from 'workbox-core';
import { precacheAndRoute, type PrecacheEntry, createHandlerBoundToURL } from 'workbox-precaching';
import { registerRoute, NavigationRoute } from 'workbox-routing';
import { CacheFirst, StaleWhileRevalidate, NetworkFirst } from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';

declare global {
  interface ServiceWorkerGlobalScope {
    skipWaiting(): Promise<void>;
    __WB_MANIFEST: Array<string | PrecacheEntry>;
  }
}

declare const self: ServiceWorkerGlobalScope;

// Take control of all pages immediately
clientsClaim();
self.skipWaiting();

// Precache all assets generated by the build process
precacheAndRoute(self.__WB_MANIFEST);

// Handle SPA navigation
const handler = createHandlerBoundToURL('/index.html');
const navigationRoute = new NavigationRoute(handler, {
  // Don't handle API or static asset requests
  denylist: [/^\/api\//, /\.(json|xml|csv|txt|js|css|png|jpg|jpeg|gif|ico|svg)$/],
});
registerRoute(navigationRoute);

// Cache images with a Cache First strategy
registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'images-cache',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 60, // Limit the number of cached images
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
        purgeOnQuotaError: true, // Automatically cleanup if storage quota is exceeded
      }),
    ],
  }),
);

// Cache CSS and JavaScript with a Stale While Revalidate strategy
registerRoute(
  ({ request }) =>
    request.destination === 'script' ||
    request.destination === 'style',
  new StaleWhileRevalidate({
    cacheName: 'static-resources',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxAgeSeconds: 7 * 24 * 60 * 60, // 7 days
        purgeOnQuotaError: true,
      }),
    ],
  }),
);

// Cache API responses with a Network First strategy for dynamic content
registerRoute(
  ({ url }) => url.pathname.startsWith('/api/'),
  new NetworkFirst({
    cacheName: 'api-cache',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 5 * 60, // 5 minutes
        purgeOnQuotaError: true,
      }),
    ],
    networkTimeoutSeconds: 5, // Extended timeout for mobile networks
  }),
);

// Cache fonts with a Cache First strategy
registerRoute(
  ({ request }) => request.destination === 'font',
  new CacheFirst({
    cacheName: 'fonts-cache',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 30,
        maxAgeSeconds: 365 * 24 * 60 * 60, // 1 year
        purgeOnQuotaError: true,
      }),
    ],
  }),
);

// Add offline fallback
const offlineFallback = async () => new Response(
  'You are offline. Please check your internet connection.',
  {
    status: 503,
    statusText: 'Service Unavailable',
    headers: {
      'Content-Type': 'text/plain',
    },
  }
);

// Register offline fallback route
registerRoute(
  () => true, // Catch all handler
  async (params) => {
    try {
      // Attempt the network request
      return await fetch(params.request);
    } catch (error) {
      // Return offline fallback if network request fails
      return offlineFallback();
    }
  },
  'GET'
);