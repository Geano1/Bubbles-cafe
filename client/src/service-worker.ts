import { clientsClaim } from 'workbox-core';
import { precacheAndRoute, type PrecacheEntry, createHandlerBoundToURL } from 'workbox-precaching';
import { registerRoute, NavigationRoute } from 'workbox-routing';
import { CacheFirst, StaleWhileRevalidate, NetworkFirst } from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';

declare global {
  interface ServiceWorkerGlobalScope {
    skipWaiting(): Promise<void>;
    __WB_MANIFEST: Array<string | PrecacheEntry>;
  }
}

declare const self: ServiceWorkerGlobalScope;

// Take control of all pages immediately
clientsClaim();
self.skipWaiting();

// Precache all assets generated by the build process
precacheAndRoute(self.__WB_MANIFEST);

// Handle SPA navigation
const handler = createHandlerBoundToURL('/index.html');
const navigationRoute = new NavigationRoute(handler, {
  // Don't handle API or static asset requests
  denylist: [/^\/api\//, /\.(json|xml|csv|txt|js|css|png|jpg|jpeg|gif|ico|svg)$/],
});
registerRoute(navigationRoute);

// Cache images with a Cache First strategy
registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'images-cache',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 60, // Limit the number of cached images
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
        purgeOnQuotaError: true, // Automatically cleanup if storage quota is exceeded
      }),
    ],
  }),
);

// Cache CSS and JavaScript with a Stale While Revalidate strategy
registerRoute(
  ({ request }) =>
    request.destination === 'script' ||
    request.destination === 'style',
  new StaleWhileRevalidate({
    cacheName: 'static-resources',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxAgeSeconds: 7 * 24 * 60 * 60, // 7 days
        purgeOnQuotaError: true,
      }),
    ],
  }),
);

// Cache API responses with a Network First strategy for dynamic content
registerRoute(
  ({ url }) => url.pathname.startsWith('/api/'),
  new NetworkFirst({
    cacheName: 'api-cache',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 5 * 60, // 5 minutes
        purgeOnQuotaError: true,
      }),
    ],
    networkTimeoutSeconds: 5, // Extended timeout for mobile networks
  }),
);

// Cache fonts with a Cache First strategy
registerRoute(
  ({ request }) => request.destination === 'font',
  new CacheFirst({
    cacheName: 'fonts-cache',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 30,
        maxAgeSeconds: 365 * 24 * 60 * 60, // 1 year
        purgeOnQuotaError: true,
      }),
    ],
  }),
);

// Add offline fallback
const offlineFallback = async () => new Response(
  'You are offline. Please check your internet connection.',
  {
    status: 503,
    statusText: 'Service Unavailable',
    headers: {
      'Content-Type': 'text/plain',
    },
  }
);

// Register offline fallback route
registerRoute(
  () => true, // Catch all handler
  async (params) => {
    try {
      // Attempt the network request
      return await fetch(params.request);
    } catch (error) {
      // Return offline fallback if network request fails
      return offlineFallback();
    }
  },
  'GET'
);
/// <reference lib="webworker" />
import { clientsClaim } from 'workbox-core';
import { precacheAndRoute, createHandlerBoundToURL } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { StaleWhileRevalidate, CacheFirst, NetworkFirst } from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';

declare const self: ServiceWorkerGlobalScope;

// Client claim allows the service worker to start controlling all pages immediately
clientsClaim();

// Precache all assets generated by vite-plugin-pwa
precacheAndRoute(self.__WB_MANIFEST);

// Set up App Shell - Single Page App routing
const fileExtensionRegexp = new RegExp('/[^/?]+\\.[^/]+$');
registerRoute(
  // Return false for URLs that have a file extension, so they're not treated as SPA navigation routes
  ({ request, url }: { request: Request; url: URL }) =>
    request.mode === 'navigate' && !url.pathname.match(fileExtensionRegexp),
  createHandlerBoundToURL('/index.html')
);

// Cache CSS, JS, Web Fonts with a stale-while-revalidate strategy
registerRoute(
  ({ request }) =>
    request.destination === 'style' ||
    request.destination === 'script' ||
    request.destination === 'font',
  new StaleWhileRevalidate({
    cacheName: 'static-resources',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 30,
        maxAgeSeconds: 60 * 60 * 24 * 30, // 30 days
      }),
    ],
  })
);

// Cache images with a cache-first strategy
registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'images',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 60 * 60 * 24 * 30, // 30 days
      }),
    ],
  })
);

// Cache API requests with a network-first strategy
registerRoute(
  ({ url }) => url.pathname.startsWith('/api/'),
  new NetworkFirst({
    cacheName: 'api-responses',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 60 * 60 * 24, // 1 day
      }),
    ],
  })
);

// Special case for homepage and story content - network first but fallback to cache
registerRoute(
  ({ url }) => 
    url.pathname === '/' || 
    url.pathname.startsWith('/story/') ||
    url.pathname.startsWith('/horror/'),
  new NetworkFirst({
    cacheName: 'pages',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 20,
        maxAgeSeconds: 60 * 60 * 24 * 7, // 7 days
      }),
    ],
  })
);

// Offline fallback - serve a custom offline page when all else fails
self.addEventListener('fetch', event => {
  // Only handle HTML navigation requests that fail
  if (
    event.request.mode === 'navigate' &&
    !event.request.url.includes('/api/')
  ) {
    event.respondWith(
      fetch(event.request).catch(() => {
        return caches.match('/offline.html');
      })
    );
  }
});

// Add offline page to precache
self.addEventListener('install', event => {
  const offlinePageUrl = '/offline.html';
  event.waitUntil(
    fetch(offlinePageUrl).then(response => {
      return caches.open('offline-page').then(cache => {
        return cache.put(offlinePageUrl, response);
      });
    })
  );
});

// Skip waiting to update service worker immediately
self.skipWaiting();

// Listen for messages from clients
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});
